(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{431:function(t,a,s){t.exports=s.p+"assets/img/cornJob.6b6b40b9.png"},432:function(t,a,s){t.exports=s.p+"assets/img/timeCorn.8a4fbabb.png"},500:function(t,a,s){"use strict";s.r(a);var r=s(0),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("blockquote",[r("p",[t._v("面试：分布式定时任务实现方式都有哪些的？")])]),t._v(" "),r("h2",{attrs:{id:"一-考虑关键点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一-考虑关键点"}},[t._v("#")]),t._v(" 一.考虑关键点")]),t._v(" "),r("ol",[r("li",[t._v("需要有管理控制台进行任务发布。")]),t._v(" "),r("li",[t._v("任务管理系统对任务进行管理和调度。")]),t._v(" "),r("li",[t._v("下发任务到客户端进行执行。")])]),t._v(" "),r("p",[r("img",{attrs:{src:s(431),alt:"图1"}})]),t._v(" "),r("h2",{attrs:{id:"二-分布式定时任务实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二-分布式定时任务实现"}},[t._v("#")]),t._v(" 二.分布式定时任务实现")]),t._v(" "),r("h3",{attrs:{id:"数据库-定时扫描-数据库"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据库-定时扫描-数据库"}},[t._v("#")]),t._v(" 数据库(定时扫描 + 数据库)")]),t._v(" "),r("ul",[r("li",[t._v("数据库作为任务存储媒介。")]),t._v(" "),r("li",[t._v("通过一个线程进行定时扫描数据库得到可以执行的任务进行执行。")])]),t._v(" "),r("h3",{attrs:{id:"死信队列-rabbitmq-消息ttl-死信队列"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#死信队列-rabbitmq-消息ttl-死信队列"}},[t._v("#")]),t._v(" 死信队列(rabbitMq 消息ttl  + 死信队列)")]),t._v(" "),r("ul",[r("li",[t._v("用rabbitMq的ttl消息作为暂存在队列中。")]),t._v(" "),r("li",[t._v("当消息过期会扔到配置的死信队列中。")])]),t._v(" "),r("h3",{attrs:{id:"时间轮"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#时间轮"}},[t._v("#")]),t._v(" 时间轮")]),t._v(" "),r("ul",[r("li",[t._v("用环形队列做成时间片，环形队列的每个格子里维护一个链表。每个时刻有一个当前指针指向环形队列某个格子，定时器每超时一次，就把当前指针指向下环形队列的下一个格子。然后处理这个格子保存的链表里的任务。该方案时间片存放在内存，因此轮询起来效率非常高，也可以根据不同的粒度调整时间片，因此也非常灵活。\n但是该方案需要自己实现持久化与高可用，以及对储存的管理，如果没有现成的轮子开发耗时会比较长。")])]),t._v(" "),r("p",[r("img",{attrs:{src:s(432),alt:"图2"}})]),t._v(" "),r("ol",[r("li",[t._v("无法实现HA和横向扩展，要么就使用多个时间轮。")]),t._v(" "),r("li",[t._v("最重要的是，实现也比较复杂，开发者需要考虑所有可能的情况。")])]),t._v(" "),r("blockquote",[r("p",[t._v("备注: Netty中已经有了一个时间轮的实现,可以参考它的源代码 : https://github.com/netty/netty/blob/4.1/common/src/main/java/io/netty/util/HashedWheelTimer.java")])]),t._v(" "),r("h3",{attrs:{id:"redis-zset"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis-zset"}},[t._v("#")]),t._v(" Redis Zset")]),t._v(" "),r("p",[t._v("将任务的执行时间作为score，要执行的任务数据作为value，存放在zset中；\n用一个进程定时查询zset的score分数最小的元素，可以用ZRANGEBYSCORE key -inf +inf limit 0 1 withscores命令来实现;\n如果最小的分数小于等于当前时间戳，就将该任务取出来执行，否则休眠一段时间后再查询")]),t._v(" "),r("h4",{attrs:{id:"缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),r("ol",[r("li",[t._v("单个 zset 肯定支持不了太大的数据量，如果你有几百万的延迟任务需求。")]),t._v(" "),r("li",[t._v("定时器轮询方案可能会有异常终止的情况需要自己处理，同时消息处理失败的回滚方案，也要自己处理。")])]),t._v(" "),r("h4",{attrs:{id:"优点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),r("ol",[r("li",[t._v("开发成本小,快速落地")]),t._v(" "),r("li",[t._v("redis来实现可以依赖于redis自身的持久化来实现持久化，redis的集群来支持高并发和高可用")])]),t._v(" "),r("br"),t._v(" "),r("h2",{attrs:{id:"三-分布式定时任务框架"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三-分布式定时任务框架"}},[t._v("#")]),t._v(" 三.分布式定时任务框架")]),t._v(" "),r("ol",[r("li",[t._v("Quartz：Java事实上的定时任务标准。但Quartz关注点在于定时任务而非数据，并无一套根据数据处理而定制化的流程。虽然Quartz可以基于数据库实现作业的高可用，但缺少分布式并行调度的功能。源码：\nhttps://github.com/quartz-scheduler/quartz")]),t._v(" "),r("li",[t._v("xxl-job: 是大众点评员工徐雪里于2015年发布的分布式任务调度平台，是一个轻量级分布式任务调度框架，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。源码：https://github.com/xuxueli/xxl-job")]),t._v(" "),r("li",[t._v("elastic-job：当当开发的弹性分布式任务调度系统，功能丰富强大，采用zookeeper实现分布式协调，实现任务高可用以及分片，贡献给了apache。源码：https://github.com/apache/shardingsphere-elasticjob")]),t._v(" "),r("li",[t._v("Saturn：是唯品会自主研发的分布式的定时任务的调度平台，基于当当的elastic-job 版本1开发，并且可以很好的部署到docker容器上。")]),t._v(" "),r("li",[t._v("antares：我用过的一个定时任务调度平台。源码： https://github.com/ihaolin/antares")])])])}),[],!1,null,null,null);a.default=e.exports}}]);