(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{592:function(e,t,_){e.exports=_.p+"assets/img/lock.ce43e23d.png"},593:function(e,t,_){e.exports=_.p+"assets/img/distributedLock.cd091309.png"},594:function(e,t,_){e.exports=_.p+"assets/img/lockFeature.4a4e1ee3.png"},595:function(e,t,_){e.exports=_.p+"assets/img/redLock.fe8d2424.png"},596:function(e,t,_){e.exports=_.p+"assets/img/zookeeperLock.32e62bd6.jpeg"},646:function(e,t,_){"use strict";_.r(t);var a=_(10),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"一-分布式锁概念与作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一-分布式锁概念与作用"}},[e._v("#")]),e._v(" 一.分布式锁概念与作用")]),e._v(" "),a("h3",{attrs:{id:"锁的一些概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#锁的一些概念"}},[e._v("#")]),e._v(" 锁的一些概念")]),e._v(" "),a("ul",[a("li",[e._v("线程安全: 线程操作的原子性、可见行、有序性。")]),e._v(" "),a("li",[e._v("锁: 用于锁定一个临界区间，同一时间只能有一个线程进来操作资源，保证了线程安全。")]),e._v(" "),a("li",[e._v("分布式锁: 分布式系统环境下为了保证临界区间同一时间只能有一个线程进来操作的锁机制。")])]),e._v(" "),a("blockquote",[a("p",[e._v("备注：需要强调的是，没有资源共享就不存在线程安全问题，也就不需要锁。")])]),e._v(" "),a("p",[a("img",{attrs:{src:_(592),alt:"锁"}})]),e._v(" "),a("p",[a("img",{attrs:{src:_(593),alt:"分布式锁"}})]),e._v(" "),a("h3",{attrs:{id:"分布式锁作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁作用"}},[e._v("#")]),e._v(" 分布式锁作用")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("分布式锁来保证共享资源的线程安全，同一时间只能有一个线程访问资源，资源互斥访问。")])]),e._v(" "),a("li",[a("p",[e._v("避免分布式中的不同节点执行重复性的工作，即用于任务互斥执行，如定时任务执行。")])])]),e._v(" "),a("blockquote",[a("p",[e._v("备注：用分布式锁要明确是用来做资源互斥访问的，还是用来做不同节点间的任务互斥。在资源互斥访问是否可以使用 CAS 这样的方式（无锁方式）来做。")])]),e._v(" "),a("h2",{attrs:{id:"二-分布式锁特点剖析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二-分布式锁特点剖析"}},[e._v("#")]),e._v(" 二.分布式锁特点剖析")]),e._v(" "),a("p",[a("img",{attrs:{src:_(594),alt:"分布式锁特点"}}),e._v("\n一般来说，生产环境可用的分布式锁需要满足以下几点：")]),e._v(" "),a("ul",[a("li",[e._v("互斥性，互斥是锁的基本特征，同一时刻只能有一个线程持有锁，执行临界操作；")]),e._v(" "),a("li",[e._v("超时释放，超时释放是锁的另一个必备特性，可以对比 MySQL InnoDB 引擎中的 innodb_lock_wait_timeout 配置，通过超时释放，防止不必要的线程等待和资源浪费；")]),e._v(" "),a("li",[e._v("可重入，在分布式环境下，同一个节点上的同一个线程如果获取了锁之后，再次请求还是可以成功；")]),e._v(" "),a("li",[e._v("高可用，加锁和解锁的开销要尽可能的小，同时也需要保证高可用，防止分布式锁失效；")]),e._v(" "),a("li",[e._v("支持阻塞和非阻塞性，对比 Java 语言中的 wait() 和 notify() 等操作，这个一般是在业务代码中实现，比如在获取锁时通过 while(true) 或者轮询来实现阻塞操作。")])]),e._v(" "),a("h2",{attrs:{id:"三-分布式锁实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三-分布式锁实现"}},[e._v("#")]),e._v(" 三.分布式锁实现")]),e._v(" "),a("h3",{attrs:{id:"分布式锁的实现方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁的实现方式"}},[e._v("#")]),e._v(" 分布式锁的实现方式")]),e._v(" "),a("ul",[a("li",[e._v("基于数据库实现：数据库乐观锁（CAS方式或版本号方式）、数据库唯一索引；")]),e._v(" "),a("li",[e._v("基于分布式缓存实现：典型代表有 Redis；")]),e._v(" "),a("li",[e._v("基于分布式一致性算法实现，典型代表有 ZooKeeper、Chubby 和 ETCD。")])]),e._v(" "),a("h3",{attrs:{id:"基于数据库实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于数据库实现"}},[e._v("#")]),e._v(" 基于数据库实现")]),e._v(" "),a("h4",{attrs:{id:"基于数据库唯一索引实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于数据库唯一索引实现"}},[e._v("#")]),e._v(" 基于数据库唯一索引实现")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("创建一个表用于加锁，通过创建和查询表数据来实现分布式锁：\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("    CREATE TABLE `order_distributed_lock`  (\n        `id` int(11) NOT NULL AUTO_INCREMENT,\n        `order_no_key` int(11) DEFAULT NULL comment '订单号作为锁key',\n        `order_no_value` varchar(50) DEFAULT NULL '当前加锁的value',\n        `lock_thread_id` varchar(50) NOT NULL,\n        `lock_enter_num` int(4) DEFAULT 0 comment '锁重入次数',\n        `lock_expired_date` datetime(0) NOT NULL comment '锁过期时间',\n        `create_date` datetime(0) NOT NULL comment '锁创建时间',\n        PRIMARY KEY (`id`) USING BTREE,\n        UNIQUE INDEX `idx_order`(`order_no_key`) USING BTREE\n    ) ENGINE = InnoDB COMMENT='订单分布式锁';\n\n")])])]),a("ul",[a("li",[e._v("order_no_key是锁的key是唯一索引，多个线程插入只能有一个插入成功。")]),e._v(" "),a("li",[e._v("order_no_value是锁的value，删除记录时需要对比order_no_value是不是自己线程的。")]),e._v(" "),a("li",[e._v("lock_thread_id是加锁的线程id，用于重入判断。")]),e._v(" "),a("li",[e._v("lock_enter_num是锁重入次数，当数值为0时才能释放锁。")]),e._v(" "),a("li",[e._v("lock_expired_date是锁的过期时间，可以用定时任务扫描该表删除过期的锁记录。")])]),e._v(" "),a("ol",[a("li",[e._v("互斥性：唯一索引保证了。")]),e._v(" "),a("li",[e._v("可重入：lock_thread_id和lock_enter_num保证了。")]),e._v(" "),a("li",[e._v("高可用：mysql的高可用机制来保证锁的高可用。")]),e._v(" "),a("li",[e._v("阻塞与非阻塞：默认插入失败就返回了是非阻塞的，想要阻塞可以通过while(true){}来实现。")]),e._v(" "),a("li",[e._v("锁超时：当超过时间lock_expired_date，锁就超时了，会被定时任务删除锁记录。")])]),e._v(" "),a("h4",{attrs:{id:"基于数据库乐观锁实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于数据库乐观锁实现"}},[e._v("#")]),e._v(" 基于数据库乐观锁实现")]),e._v(" "),a("ol",[a("li",[e._v("适用场景：乐观锁适用于读多写少的场景，也就是说适用于锁争抢不激烈的场景。")]),e._v(" "),a("li",[e._v("核心思路：就是程序开始前获取版本号或原始值，执行更新时用CAS或版本号方式对比数据是否发生变化。")]),e._v(" "),a("li",[e._v("存在问题：因为使用乐观锁方式实现的，主要存在两大问题，一是会存在ABA问题，二是只能保证一个共享变量原子操作。")])]),e._v(" "),a("h3",{attrs:{id:"基于redis实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于redis实现"}},[e._v("#")]),e._v(" 基于redis实现")]),e._v(" "),a("h4",{attrs:{id:"扩展set指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#扩展set指令"}},[e._v("#")]),e._v(" 扩展set指令")]),e._v(" "),a("ul",[a("li",[e._v("SET key value PX 1000 NX ：当key不存在的时候设置key-value，并设置过期时间为1秒。")]),e._v(" "),a("li",[e._v("它只是一个单纯的将设置kv与设置过期时间的动作作为了一个原子指令进行操作。")]),e._v(" "),a("li",[e._v("通常我们通过自己在客户端写lua脚本或者用三方redis客户端来实现更完善的reids锁。")])]),e._v(" "),a("h4",{attrs:{id:"redlock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redlock"}},[e._v("#")]),e._v(" Redlock")]),e._v(" "),a("ul",[a("li",[e._v("核心思想：在Redis的分布式环境中，假设我们有N个Redis主机；这些节点是完全独立的，因此我们不使用复制或任何其他隐式协调系统；当且仅当从大多数(N/2+1，这里是3个节点)的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。")]),e._v(" "),a("li",[e._v("锁的有效时间为：锁设置时间 - 半数以上加锁成功耗时 - 漂移时间。")])]),e._v(" "),a("p",[a("img",{attrs:{src:_(595),alt:"红锁"}})]),e._v(" "),a("h3",{attrs:{id:"基于zookeeper实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于zookeeper实现"}},[e._v("#")]),e._v(" 基于zookeeper实现")]),e._v(" "),a("h4",{attrs:{id:"zookeeper实现核心思想"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper实现核心思想"}},[e._v("#")]),e._v(" zookeeper实现核心思想")]),e._v(" "),a("ul",[a("li",[e._v("锁创建：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的临时有序节点。")]),e._v(" "),a("li",[e._v("锁获取：判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。")]),e._v(" "),a("li",[e._v("锁释放：当释放锁的时候，只需将这个瞬时节点删除即可，临时有序节点每一个节点都持有前一个节点的watch，锁释放触发watch事件，次小节点获取锁。\n"),a("img",{attrs:{src:_(596),alt:"zookeeper锁"}})])]),e._v(" "),a("h4",{attrs:{id:"zookeeper网络问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper网络问题"}},[e._v("#")]),e._v(" zookeeper网络问题")]),e._v(" "),a("ul",[a("li",[e._v("问题概述：Zookeeper实现的分布式锁，网络问题锁释放了怎么办？")])]),e._v(" "),a("ol",[a("li",[e._v("使用Zookeeper也有可能带来并发问题，只是并不常见而已。")]),e._v(" "),a("li",[e._v("由于网络抖动，客户端可ZK集群的session连接断了，那么zk以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了。就可能产生并发问题了。")]),e._v(" "),a("li",[e._v("这个问题不常见是因为zk有重试机制，一旦zk集群检测不到客户端的心跳，就会重试，Curator客户端支持多种重试策略。多次重试之后还不行的话才会删除临时节点。")])]),e._v(" "),a("blockquote",[a("p",[e._v("Tip：所以，选择一个合适的重试策略也比较重要，要在锁的粒度和并发之间找一个平衡。")])]),e._v(" "),a("ul",[a("li",[e._v("解决方案：")])]),e._v(" "),a("ol",[a("li",[e._v("当这种问题真的发生了，需要我们在业务上进行数据回滚，比如当删除临时有序节点连不上zk集群或连上发现节点不存在，那我们就要回滚业务数据。或者结合数据库记录版本号，更新时发现不一致就不做业务操作等。")])]),e._v(" "),a("blockquote",[a("p",[e._v("文章参考：")])]),e._v(" "),a("ul",[a("li",[e._v("https://learn.lianglianglee.com/")]),e._v(" "),a("li",[e._v("https://www.cnblogs.com/aobing/p/12650036.html")])])])}),[],!1,null,null,null);t.default=r.exports}}]);